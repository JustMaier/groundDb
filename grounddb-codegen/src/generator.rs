use grounddb::schema::SchemaDefinition;
use proc_macro2::TokenStream;
use quote::quote;

use crate::enum_gen::generate_enums;
use crate::store_gen::generate_store_ext;
use crate::struct_gen::generate_structs;
use crate::view_gen::generate_views;

/// Generate all code from a parsed schema definition.
/// Returns a TokenStream containing the complete generated module.
pub fn generate_all(schema: &SchemaDefinition) -> TokenStream {
    let enums = generate_enums(schema);
    let structs = generate_structs(schema);
    let views = generate_views(schema);
    let store_ext = generate_store_ext(schema);

    quote! {
        //! Auto-generated by grounddb-codegen. Do not edit manually.

        #![allow(unused_imports)]
        #![allow(dead_code)]

        use serde::{Serialize, Deserialize};

        // ── Enums ──────────────────────────────────────────────

        #enums

        // ── Structs ────────────────────────────────────────────

        #structs

        // ── Views ──────────────────────────────────────────────

        #views

        // ── Store Extension ────────────────────────────────────

        #store_ext
    }
}

/// Format a TokenStream into a readable Rust source string.
pub fn format_token_stream(tokens: &TokenStream) -> String {
    let file_content = tokens.to_string();

    // Try to use prettyplease for formatting if available,
    // otherwise fall back to basic formatting
    match syn::parse_file(&file_content) {
        Ok(parsed) => prettyplease::unparse(&parsed),
        Err(_) => {
            // Fallback: return unformatted but valid Rust
            file_content
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use grounddb::schema::{
        CollectionDefinition, FieldDefinition, FieldType, RefTarget, SchemaDefinition,
        ViewDefinition, ParamDefinition,
    };
    use std::collections::HashMap;

    fn test_schema() -> SchemaDefinition {
        let mut types = HashMap::new();
        let mut address_fields = HashMap::new();
        address_fields.insert(
            "street".to_string(),
            FieldDefinition {
                field_type: FieldType::String,
                required: true,
                enum_values: None,
                default: None,
                target: None,
                items: None,
                on_delete: None,
            },
        );
        address_fields.insert(
            "city".to_string(),
            FieldDefinition {
                field_type: FieldType::String,
                required: true,
                enum_values: None,
                default: None,
                target: None,
                items: None,
                on_delete: None,
            },
        );
        types.insert("address".to_string(), address_fields);

        let mut collections = HashMap::new();

        // Users collection
        let mut user_fields = HashMap::new();
        user_fields.insert(
            "name".to_string(),
            FieldDefinition {
                field_type: FieldType::String,
                required: true,
                enum_values: None,
                default: None,
                target: None,
                items: None,
                on_delete: None,
            },
        );
        user_fields.insert(
            "email".to_string(),
            FieldDefinition {
                field_type: FieldType::String,
                required: true,
                enum_values: None,
                default: None,
                target: None,
                items: None,
                on_delete: None,
            },
        );
        user_fields.insert(
            "role".to_string(),
            FieldDefinition {
                field_type: FieldType::String,
                required: false,
                enum_values: Some(vec![
                    "admin".to_string(),
                    "member".to_string(),
                    "guest".to_string(),
                ]),
                default: Some(serde_yaml::Value::String("member".to_string())),
                target: None,
                items: None,
                on_delete: None,
            },
        );
        collections.insert(
            "users".to_string(),
            CollectionDefinition {
                path: "users/{name}.md".to_string(),
                fields: user_fields,
                content: false,
                additional_properties: false,
                strict: true,
                readonly: false,
                on_delete: None,
                id: None,
            },
        );

        // Posts collection
        let mut post_fields = HashMap::new();
        post_fields.insert(
            "title".to_string(),
            FieldDefinition {
                field_type: FieldType::String,
                required: true,
                enum_values: None,
                default: None,
                target: None,
                items: None,
                on_delete: None,
            },
        );
        post_fields.insert(
            "author_id".to_string(),
            FieldDefinition {
                field_type: FieldType::Ref,
                required: true,
                enum_values: None,
                default: None,
                target: Some(RefTarget::Single("users".to_string())),
                items: None,
                on_delete: None,
            },
        );
        post_fields.insert(
            "status".to_string(),
            FieldDefinition {
                field_type: FieldType::String,
                required: false,
                enum_values: Some(vec![
                    "draft".to_string(),
                    "published".to_string(),
                    "archived".to_string(),
                ]),
                default: Some(serde_yaml::Value::String("draft".to_string())),
                target: None,
                items: None,
                on_delete: None,
            },
        );
        collections.insert(
            "posts".to_string(),
            CollectionDefinition {
                path: "posts/{status}/{title}.md".to_string(),
                fields: post_fields,
                content: true,
                additional_properties: false,
                strict: true,
                readonly: false,
                on_delete: None,
                id: None,
            },
        );

        // Views
        let mut views = HashMap::new();
        views.insert(
            "post_feed".to_string(),
            ViewDefinition {
                query: "SELECT p.title, u.name AS author_name FROM posts p JOIN users u ON p.author_id = u.id WHERE p.status = 'published' ORDER BY p.date DESC LIMIT 100".to_string(),
                view_type: None,
                materialize: true,
                buffer: Some("2x".to_string()),
                params: None,
            },
        );

        let mut post_comments_params = HashMap::new();
        post_comments_params.insert(
            "post_id".to_string(),
            ParamDefinition {
                param_type: "string".to_string(),
            },
        );
        views.insert(
            "post_comments".to_string(),
            ViewDefinition {
                query: "SELECT c.id, c.created_at FROM comments c WHERE c.parent = :post_id ORDER BY c.created_at ASC".to_string(),
                view_type: None,
                materialize: false,
                buffer: None,
                params: Some(post_comments_params),
            },
        );

        SchemaDefinition {
            types,
            collections,
            views,
        }
    }

    #[test]
    fn test_generate_all_produces_valid_tokens() {
        let schema = test_schema();
        let tokens = generate_all(&schema);
        let code = tokens.to_string();

        // Enums
        assert!(code.contains("UserRole"), "Missing UserRole enum");
        assert!(code.contains("PostStatus"), "Missing PostStatus enum");

        // Structs
        assert!(code.contains("pub struct User"), "Missing User struct");
        assert!(code.contains("pub struct Post"), "Missing Post struct");

        // Partial structs
        assert!(code.contains("pub struct UserPartial"), "Missing UserPartial");
        assert!(code.contains("pub struct PostPartial"), "Missing PostPartial");

        // Reusable types
        assert!(code.contains("pub struct Address"), "Missing Address struct");

        // Views
        assert!(code.contains("PostFeedRow"), "Missing PostFeedRow");
        assert!(code.contains("PostCommentsRow"), "Missing PostCommentsRow");
        assert!(code.contains("PostCommentsParams"), "Missing PostCommentsParams");

        // Store extension
        assert!(code.contains("StoreExt"), "Missing StoreExt trait");
        assert!(code.contains("fn users"), "Missing users method");
        assert!(code.contains("fn posts"), "Missing posts method");
    }

    #[test]
    fn test_format_token_stream() {
        let schema = test_schema();
        let tokens = generate_all(&schema);
        let formatted = format_token_stream(&tokens);

        // Should be valid Rust (parseable by syn)
        assert!(!formatted.is_empty());
        assert!(syn::parse_file(&formatted).is_ok(), "Formatted output should be valid Rust");
    }
}
